Типы данных и их форматы:
- Int: uint8, uint16, uint32, uint64, uint128, uint256, int8, int16, int32, int64, int128, int256, coins 
- Bool, Address, Cell, String, StringBuilder, Slice, Builder
- Не использовать несуществующие форматы (например, uint2)

Объявление переменных:
- Всегда явно указывайте тип: let x: Int = 0;
- Для state variables используйте форматы: value: Int as uint32; 
- Объявляйте все переменные перед использованием и инициализируйте при объявлении, если возможно

Работа с картами (map):
- Объявление: myMap: map<KeyType, ValueType>;
- Ключи могут быть только Int или Address
- Получение значения: let value = myMap.get(key);
- Установка значения: myMap.set(key, value);
- Удаление значения: myMap.set(key, null);  
- Проверка наличия ключа: if (myMap.get(key) != null) { ... }
- Для итерации используйте .keys() или .values()

Опциональные значения:
- Объявление: let x: Int?;
- Всегда проверяйте на null перед использованием: if (x != null) { ... }
- Безопасное извлечение: let value = x!!; (только после проверки на null)
- Используйте ?. для безопасного вызова методов: x?.toString()
- Предоставление значения по умолчанию: let value = x ?? defaultValue;

Контракты и сообщения:  
- Объявление контракта: 
  ```
  contract MyContract with Trait1, Trait2 { 
    // ... 
  }
  ```
- Объявление сообщения: 
  ```
  message MyMessage { 
    field1: Type1, 
    field2: Type2
  }
  ```
- Обработка сообщений: 
  ```
  receive(msg: MyMessage) { 
    // ... 
  }
  ```
- Используйте sender() для получения адреса отправителя 
- Используйте myAddress() для получения адреса текущего контракта

Функции:
- Объявление: 
  ```
  fun myFunction(param1: Type1, param2: Type2): ReturnType {
    // ...
  }
  ```
- Геттеры: get fun myGetter(): ReturnType { ... }  
- Мутирующие функции: mutates fun myMutatingFunction() { ... }
- Виртуальные функции: virtual fun myVirtualFunction() { ... }
- Переопределение функций: override fun myOverriddenFunction() { ... }

Константы:
- Объявление на уровне контракта: const MY_CONSTANT: Int = 100;
- Использование внутри функций: self.MY_CONSTANT
- Должны быть инициализированы значениями, известными на этапе компиляции
- В Tact не используются префиксы типа op:: для обращения к константам

Циклы:
- repeat (count) { ... } - не имеет встроенной переменной итерации
- while (condition) { ... }  
- Для итерации по map используйте .keys() или .values()
- Пример использования repeat с внешней переменной итерации:
  ```
  let i: Int = 0;
  repeat (5) {
    // использование i
    i = i + 1; 
  }
  ```

Условные операторы:
- if (condition) { ... } else { ... }
- Тернарный оператор: let result = condition ? trueValue : falseValue;

Битовые операции:
- Поддерживаются: &, |, ^, ~, <<, >> 
- Пример: let result = (value & 0xFF) | (1 << 8);

Работа со строками:
- Используйте StringBuilder для эффективной конкатенации строк
- Пример:
  ```
  let sb: StringBuilder = beginString();
  sb.append("Hello, ");
  sb.append("world!");
  let result: String = sb.toString(); 
  ```

Работа с числами: 
- Используйте ton("0.1") для работы с суммами в TON
- min() и max() для нахождения минимума и максимума  

Обработка ошибок:
- Используйте require(condition, "Error message");
- Проверяйте все входные данные и предусловия
- В Tact используйте require(condition, "error message") вместо throw(), характерного для FunC

Эмиссия событий:  
```
emit(MyEvent{param1: value1, param2: value2}.toCell());
```

Отправка сообщений:
- Используйте SendParameters с корректными полями
- Пример:
  ```
  send(SendParameters{
    to: recipientAddress,
    value: ton("0.1"),
    mode: SendIgnoreErrors, 
    body: MyMessage{field1: value1, field2: value2}.toCell()
  });
  ```

Импорт: 
- import "@stdlib/deploy";
- Всегда указывайте полный путь к импортируемому модулю

Работа с временем:
- Используйте now() для получения текущего времени
- Сравнивайте временные интервалы в секундах

Работа с адресами:
- Используйте address("EQB...") для создания адреса из строки
- Сравнивайте адреса с помощью ==

При работе с адресами Tact поддерживает несколько форматов, в том числе:

Сырой (raw) формат: address("EQB02DJ0cdUD4iQDRbBv4aYG3htePHBRK1tGeRtCnatescK0")
Удобочитаемые (user-friendly) форматы, bounceable и non-bounceable: address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N")

В коде можно использовать любой из этих форматов, они равнозначны. Удобочитаемые форматы содержат префикс и чексумму.
Поддерживается механизм ревью (отзыва) токенов стандарта SBT. Для этого у SBT контракта должен быть указан адрес authority. Authority может отозвать SBT в любой момент с помощью сообщения revoke. Нужно учитывать это при проектировании систем с SBT.
SBT контракт предоставляет методы prove_ownership и request_owner для доказательства владения токеном другому контракту. Эти методы позволяют создавать интересные механики с проверками владения SBT.
Стандарт Jetton поддерживает задание метаданных в offchain, onchain и смешанном (semi-chain) формате. При использовании offchain метаданных нужно предусмотреть меры безопасности на случай недоступности внешнего ресурса.
При отправке сообщений желательно указывать режим send_mode: SendRemainingValue. Это позволит вернуть отправителю неизрасходованные на газ средства.

Вот дополненные части правил с учетом этих моментов:
Часть 2. Общие рекомендации

При работе с адресами в Tact можно использовать несколько форматов:

Сырой формат address("EQB...")
Удобочитаемые форматы с префиксом и чексуммой, bounceable address("Ef...") и non-bounceable address("Uf...")
Все эти форматы равнозначны и взаимозаменяемы.


Если ваша система использует SBT (Soul Bound Tokens), учитывайте возможность отзыва (revoke) токена со стороны authority. Проверяйте статус SBT через get_revoked_time().
Чтобы проверить владение SBT на стороне другого контракта, отправляйте сообщения prove_ownership или request_owner на адрес SBT, указав в параметрах свой контракт. SBT перешлет вашему контракту нужные данные.
Для хранения метаданных Jetton и NFT в Tact есть три опции: offchain (ссылка на внешний ресурс), onchain (все данные в блокчейне) и semi-chain (часть данных в блокчейне, часть по ссылке). Взвешивайте плюсы и минусы каждого подхода. При использовании offchain не забудьте про отказоустойчивость.
При отправке сообщений через send() указывайте флаг mode: SendRemainingValue если в этом есть смысл и вам не нужно обрабатывать возврат. Это автоматически вернет отправителю неизрасходованный на газ остаток.
Максимально полно документируйте код: добавляйте комментарии к методам, параметрам, структурам. Это упростит поддержку и передачу дел.

Часть 3. Процесс проверки кода

Убедитесь, что адреса указаны в корректном формате (raw, bounceable или non-bounceable).
Проверьте, что при использовании SBT учтена возможность отзыва токена, статус SBT проверяется при необходимости.
Убедитесь, что при необходимости доказательства владения SBT используются предусмотренные стандартом методы prove_ownership или request_owner.
Убедитесь, что при хранении метаданных Jetton/NFT в offchain формате предусмотрены меры на случай недоступности внешнего ресурса.
Проверьте, что в местах, где нужно вернуть отправителю остаток средств, используется флаг SendRemainingValue при отправке.
Убедитесь, что код достаточно полно задокументирован, все основные методы, параметры и структуры имеют комментарии.

Всегда проверяйте доступные методы для типа Builder в Tact. Используйте только документированные методы.
Для хранения одного бита используйте storeUint(value, 1) вместо storeBit().
Перед использованием любого метода убедитесь, что он существует в текущей версии Tact.
Регулярно обновляйте знания о доступных методах и их правильном использовании в Tact.
При возникновении сомнений всегда обращайтесь к официальной документации Tact.
Используйте инструменты статического анализа и линтеры, специфичные для Tact, если таковые доступны.

Общие правила:  
- Внимательно изучайте предоставленный код и определяйте язык, на котором он написан
- Не делайте предположений о совместимости кода между разными языками (например, FunC и Tact)
- При работе с внешними контрактами (например, жетонами), используйте правильные операционные коды и форматы сообщений, специфичные для Tact
- Используйте beginCell() и endCell() для создания сложных сообщений в Tact
- Помните о различиях в объявлении и использовании функций между FunC и Tact:
  - В Tact используйте ключевое слово fun для объявления функций
  - В Tact явно указывайте типы параметров и возвращаемых значений
- Обратите внимание на различия в работе с картами (map) между FunC и Tact:
  - В Tact используйте методы set(), get(), а не операторы ->
- Используйте структуры данных Tact (struct) вместо кортежей, характерных для FunC
- Помните о различиях в обработке опциональных значений между FunC и Tact:
  - В Tact используйте ? для обозначения опциональных типов
  - Используйте !! для безопасного извлечения значения после проверки на null
- Изучите и используйте правильные атрибуты контракта в Tact, такие как with Deployable, OwnableTransferable
- Используйте правильный синтаксис Tact для отправки сообщений и токенов
- При переносе логики из FunC в Tact, убедитесь, что вы адаптируете все конструкции и идиомы к синтаксису и возможностям Tact
- Проверяйте документацию Tact перед использованием любой конструкции
- Комментируйте сложные части кода
- Разбивайте сложную логику на отдельные функции  
- Используйте говорящие имена для переменных и функций
- Избегайте дублирования кода
- Проверяйте граничные случаи и обрабатывайте исключения
- Регулярно обновляйте знания о Tact, следя за документацией
- При возникновении сомнений всегда обращайтесь к официальной документации Tact или спрашивайте уточнения
- Используйте инструменты статического анализа и линтеры, специфичные для Tact, если таковые доступны

Процесс проверки кода:
- Проверяйте каждую строку на соответствие синтаксису Tact
- Проверьте обработку всех опциональных значений 
- Убедитесь, что все операции с картами выполнены правильно
- Проверьте корректность отправки и обработки сообщений
- Проверьте правильность работы с адресами и временем
- Проверьте код соответствует общей архитектуре и логике контракта

