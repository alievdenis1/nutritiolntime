TON Access


HTTP API FOR
THE OPEN NETWORK (TON).
DECENTRALIZED.
The most reliable decentralized RPC network for TON dapps making HTTP queries to blockchain state from the browser. Unrestricted anonymous access without an API key.

GET STARTED



UNTHROTTLED
No throttling for

anonymous dapp users

Read more



NO API KEY
Decentralized access without

registering API keys

Read more



SERVERLESS
No need to run your own RPC

backend server

Read more



DECENTRALIZED
Trust a protocol, not a

centralized business

Read more



HIGH REDUNDANCY
Robust API with no single

point of failure

Read more



WIDE SUPPORT
Supports all RPC API flavors

HTTP v2, v4, raw ADNL

Read more


Initialize the RPC endpoint
HTTP API Flavor

TonCenter HTTP API v2


TonCenter HTTP API v2 docs

Replaces https://toncenter.com/api/v2/jsonRPC
TonHub HTTP API v4 docs

Replaces https://mainnet-v4.tonhubapi.com
Raw ADNL Proxy docs

Client Library

NPM ton


NPM ton docs

JavaScript
NPM TonWeb docs

JavaScript
CDN TonWeb docs

JavaScript
Network

Mainnet


Mainnet

Testnet

Copied!
// copy paste the following snippet into your dapp client code
// to initialize your favorite TON API library and make blockchain queries

import { getHttpEndpoint } from "@orbs-network/ton-access";
import { TonClient } from "ton";

// get the decentralized RPC endpoint
const endpoint = await getHttpEndpoint();

// initialize ton library
const client = new TonClient({ endpoint });

TON Access
Unthrottled anonymous RPC access to TON blockchain via the dozens of decentralized nodes of the Orbs Network.

Access a network of public API endpoints that allow TON dapp clients to make HTTP queries from the browser to TON blockchain (call getters, balances, get block data, etc). Access is unrestricted without an API Key and without requiring dapps to run any backend.

Supports all popular RPC protocols on TON:

TonCenter HTTP API v2 - replaces the https://toncenter.com/api/v2/jsonRPC endpoint
TonHub HTTP API v4 - replaces the https://mainnet-v4.tonhubapi.com endpoint
Raw ADNL Proxy - coming soon


Getting Started
Using NPM:

npm install @orbs-network/ton-access
Using HTML script:

<script src="https://cdn.jsdelivr.net/gh/orbs-network/ton-access@2.2.2/dist/index.min.js"></script>


1. Using TonCenter HTTP API v2
with ton library:
import { getHttpEndpoint } from "@orbs-network/ton-access";
import { TonClient, Address } from "ton";

const endpoint = await getHttpEndpoint(); // get the decentralized RPC endpoint
const client = new TonClient({ endpoint }); // initialize ton library

// make some query to mainnet
const address = Address.parseFriendly("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N").address;
const balance = await client.getBalance(address);
with TonWeb library:
import { getHttpEndpoint } from "@orbs-network/ton-access";
import TonWeb from "tonweb";

const endpoint = await getHttpEndpoint(); // get the decentralized RPC endpoint
const tonweb = new TonWeb(new TonWeb.HttpProvider(endpoint)); // initialize tonweb library

// make some query to mainnet
const balance = await tonweb.getBalance("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N");
with TonWeb as HTML script:
<script src="https://cdn.jsdelivr.net/gh/orbs-network/ton-access@2.2.0/dist/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/toncenter/tonweb/dist/tonweb.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        TonAccess.getHttpEndpoint().then((endpoint) => { // get the decentralized RPC endpoint
            const tonweb = new TonWeb(new TonWeb.HttpProvider(endpoint)); // initialize tonweb library
            // make some query to mainnet
            tonweb.getBalance("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N").then((balance) => {
                console.log(balance);
            });
        });
    });
</script>


2. Using TonHub HTTP API v4
with ton library:
import { TonClient4 } from "ton";
import { getHttpV4Endpoint } from "@orbs-network/ton-access";

const endpoint = await getHttpV4Endpoint(); // get the decentralized RPC endpoint
const client4 = new TonClient4({ endpoint }); // initialize ton library

// make some query to mainnet
const latestBlock = await client4.getLastBlock();
const latestBlockNumber = latestBlock.last.seqno;


3. Using Raw ADNL Proxy
with ton-lite-client library:
import { LiteClient, LiteSingleEngine } from "ton-lite-client";
import { getAdnlProxyEndpoint } from "@orbs-network/ton-access";

const { endpoint, publicKey } = await getAdnlProxyEndpoint();
const engine = new LiteSingleEngine({ host: endpoint, publicKey });
const client = new LiteClient({ engine });

// make some query to mainnet
const info = await liteClient.getMasterchainInfo();


API Reference
Get TonCenter HTTP API v2 endpoint:

const endpoint = await getHttpEndpoint(config: Config);
Get TonHub HTTP API v4 endpoint:

const endpoint = await getHttpV4Endpoint(config: Config);
Get Raw ADNL Proxy endpoint:

const { endpoint, publicKey } = await getAdnlProxyEndpoint(config: Config);
Use testnet instead of mainnet:

const endpoint = await getHttpEndpoint({
  network: "testnet"
});
Config object:
interface Config {
  network?: "mainnet" | "testnet" // default: mainnet
  host?: string; // default: "ton.access.orbs.network"
  accessVersion?: number; // default: 1
  protocol?: "default" | "json-rpc" | "rest"; // default: "default"
};
network - override which TON network do you want to use:
mainnet - TON mainnet (default)
testnet - the first TON testnet
accessVersion - should always be 1, reserved for future upgrades of this library
protocol - sub-protocol to use, depends on the type of API:
TonCenter HTTP API v2:
default - json-rpc
json-rpc - supported
rest- supported
TonHub HTTP API v4:
default - rest
json-rpc - not supported
rest - supported
Raw ADNL Proxy:
default - adnl
json-rpc - not supported
rest - not supported


Benefits of using the Orbs TON Access
No throttling for anonymous users

RPC access like https://toncenter.com/api/v2/jsonRPC throttle anonymous users to 1 request per second. Most dapps cannot operate under these restrictions since their users are anonymous. The Orbs Network endpoints are designed to serve anonymous dapp users and will not restrict your users from using your dapp client, except in extreme cases of abuse.

No need for registering an API Key

RPC access like https://toncenter.com/api/v2/jsonRPC reduce user throttling by requiring you to register an API Key. This API Key cannot be stored client-side since it can be abused (it's supposed to be a secret) and dapps should not run a centralized backend to store this secret since they should be decentralized.

No need to run your own RPC backend

If you're building a dapp, your dapp should be decentralized so it can be trustless. If you're running your own centralized backend as part of your dapp, you've made your dapp centralized. If your backend suffers downtime for example, your users will lose access to their funds. If the infrastructure is decentralized, you don't need to worry about it.

Decentralized access to the chain

By relying on https://toncenter.com/api/v2/jsonRPC, you're relying on a centralized business (toncenter.com), not a protocol. The Orbs Network TON-Access is a decentralized protocol operated by dozens of independent nodes that are all part of the Orbs Network. The network mainnet is running since 2019 and validators are staked with Proof-of-Stake consensus with over $100 million TVL locked. The network is extremely robust against downtime due to the number of independent nodes.

Version Changes
v2.3.0

As of this version, the client calls edge/mngr/nodes instead of edge/nodes
The resulr comes as an array of nodes in this format
{
  "NodeId": "19e116699fd6c7ad754a912af633aafec27cc456",
  "BackendName": "be2",
  "Ip": "3.142.212.29",
  "Weight": 100,
  "Healthy": "1",
  "Mngr": {
  "updated": "Mon, 27 Feb 2023 13:31:16 GMT",
  "health": {
    "v2-mainnet": true,
    "v2-testnet": true,
    "v4-mainnet": true,
    "v4-testnet": true
  },
  "successTS": 1677504676523,
  "errors": [],
  "code": 200,
  "text": "OK"
  }
},
This way the client is aware of which nodes support which protocol-network and can chose a random node in a more responsible way.
Weight field is also taken into consideration during the random node choice.
TON HTTP API
 2.0.0
OAS 3.1
/api/v2/openapi.json
This API enables HTTP access to TON blockchain - getting accounts and wallets information, looking up blocks and transactions, sending messages to the blockchain, calling get methods of smart contracts, and more.

In addition to REST API, all methods are available through JSON-RPC endpoint with method equal to method name and params passed as a dictionary.

The response contains a JSON object, which always has a boolean field ok and either error or result. If ok equals true, the request was successful and the result of the query can be found in the result field. In case of an unsuccessful request, ok equals false and the error is explained in the error.

API Key should be sent either as api_key query parameter or X-API-Key header.

Servers

/api/v2

Authorize
accounts
Information about accounts.



GET
/getAddressInformation
Get Address Information



GET
/getExtendedAddressInformation
Get Extended Address Information



GET
/getWalletInformation
Get Wallet Information



GET
/getTransactions
Get Transactions



GET
/getAddressBalance
Get Address Balance



GET
/getAddressState
Get Address



GET
/packAddress
Pack Address



GET
/unpackAddress
Unpack Address



GET
/getTokenData
Get Token Data



GET
/detectAddress
Detect Address


blocks
Information about blocks.



GET
/getMasterchainInfo
Get Masterchain Info



GET
/getMasterchainBlockSignatures
Get Masterchain Block Signatures



GET
/getShardBlockProof
Get Shard Block Proof



GET
/getConsensusBlock
Get Consensus Block



GET
/lookupBlock
Lookup Block



GET
/shards
Get Shards



GET
/getBlockTransactions
Get Block Transactions



GET
/getBlockTransactionsExt
Get Block Transactions Ext



GET
/getBlockHeader
Get Block Header



GET
/getOutMsgQueueSizes
Get Out Msg Queue Sizes


transactions
Fetching and locating transactions.



GET
/getTransactions
Get Transactions



GET
/getBlockTransactions
Get Block Transactions



GET
/getBlockTransactionsExt
Get Block Transactions Ext



GET
/tryLocateTx
Get Try Locate Tx



GET
/tryLocateResultTx
Get Try Locate Result Tx



GET
/tryLocateSourceTx
Get Try Locate Source Tx


get config
Get blockchain config



GET
/getConfigParam
Get Config Param



GET
/getConfigAll
Get Config All


run method
Run get method of smart contract.



POST
/runGetMethod
Run Get Method


send
Send data to blockchain.



POST
/sendBoc
Send Boc



POST
/sendBocReturnHash
Send Boc Return Hash



POST
/sendQuery
Send Query



POST
/estimateFee
Estimate Fee


json rpc
JSON-RPC endpoint.



POST
/jsonRPC
Jsonrpc Handler



Schemas
Body_estimate_fee_estimateFee_postExpand allobject
Body_run_get_method_runGetMethod_postExpand allobject
Body_send_boc_return_hash_sendBocReturnHash_postExpand allobject
Body_send_boc_sendBoc_postExpand allobject
Body_send_query_sendQuery_postExpand allobject
DeprecatedTonResponseJsonRPCExpand allobject
TonRequestJsonRPCExpand allobject
TonResponseExpand allobject

tonweb
TonWeb - JavaScript SDK for The Open Network
NPM

Install Web
npm install tonweb or yarn add tonweb

import TonWeb from "tonweb";

const tonweb = new TonWeb();
or

<script src="tonweb.js"></script>

const tonweb = new window.TonWeb();

Install NodeJS
npm install tonweb or yarn add tonweb

const TonWeb = require('tonweb');

const tonweb = new TonWeb();
Overview example
const tonweb = new TonWeb();

const wallet = tonweb.wallet.create({publicKey});

const address = await wallet.getAddress();

const nonBounceableAddress = address.toString(true, true, false);

const seqno = await wallet.methods.seqno().call();

await wallet.deploy(secretKey).send(); // deploy wallet to blockchain

const fee = await wallet.methods.transfer({
    secretKey,
    toAddress: 'EQDjVXa_oltdBP64Nc__p397xLCvGm2IcZ1ba7anSW0NAkeP',
    amount: TonWeb.utils.toNano(0.01), // 0.01 TON
    seqno: seqno,
    payload: 'Hello',
    sendMode: 3,
}).estimateFee();

const Cell = TonWeb.boc.Cell;
const cell = new Cell();
cell.bits.writeUint(0, 32);
cell.bits.writeAddress(address);
cell.bits.writeGrams(1);
console.log(cell.print()); // print cell data like Fift
const bocBytes = cell.toBoc();

const history = await tonweb.getTransactions(address);

const balance = await tonweb.getBalance(address);

tonweb.sendBoc(bocBytes);
API
By default, mainnet toncenter.com API is used. Please note that without the API key there will be a request rate limit.

You can start your own TON HTTP API instance as it is open source.

Use mainnet TonCenter API with high ratelimit API key:

const tonweb = new TonWeb(new TonWeb.HttpProvider('https://toncenter.com/api/v2/jsonRPC', {apiKey: 'YOUR_MAINNET_TONCENTER_API_KEY'}));
Use testnet TonCenter API with high ratelimit API key:

const tonweb = new TonWeb(new TonWeb.HttpProvider('https://testnet.toncenter.com/api/v2/jsonRPC', {apiKey: 'YOUR_TESTNET_TONCENTER_API_KEY'}));
Documentation
Each part is documented separately:

tonweb - root class and methods

tonweb-contract-wallet - interaction with wallet's smart contracts.

tonweb-contract - abstract interface to interact with TON smart contracts.

tonweb-boc - serializations of Cell and BitString

tonweb-utils - work with TON Addresses, coin values, byte arrays, hex, hash functions.

Also we use JSDoc in code

Roadmap
Unit-tests

Typescript

Build
npm install

npm run build
Use as alternative to Fift for building binary messages to smart-contracts
npm install -g tonweb

export NODE_PATH=$(npm root --quiet -g)
Then create your_script.js

const TonWeb = require('tonweb');

const tonweb = new TonWeb();

. . .
run script

node your_script.js

[**@ton/core**](https://github.com/ton-org/ton-core) : базовая библиотека TypeScript, которая реализует примитивы низкого уровня для блокчейна TON.

[**@ton/blueprint**](https://github.com/ton-org/blueprint) : среда разработки TON для написания, тестирования и развертывания смарт-контрактов.

[**@ton/sandbox**](https://github.com/ton-org/sandbox) : среда тестирования для эмуляции произвольных смарт-контрактов TON, отправки им сообщений и запуска методов get, как если бы они были развернуты в реальной сети.

JS SDK TON SENETR https://github.com/toncenter/tonweb

import {Address, TonClient4} from "@ton/ton";
import {getHttpV4Endpoint, Network} from "@orbs-network/ton-access";
import {createHighloadV2, ExtendedOpenedContract, GameFiSDK} from "@ton-community/gamefi-sdk";

Sandbox
This package allows you to emulate arbitrary TON smart contracts, send messages to them and run get methods on them as if they were deployed on a real network.

The key difference of this package from ton-contract-executor is the fact that the latter only emulates the compute phase of the contract - it does not know about any other phases and thus does not know anything about fees and balances (in a sense that it does not know whether a contract's balance will be enough to process all the out messages that it produces). On the other hand, this package emulates all the phases of a contract, and as a result, the emulation is much closer to what would happen in a real network.

Content
Instalation
Usage
Writing Tests
Basic test template
Test a transaction with matcher
Testing transaction fees
Cross contract tests
Testing key points
Test examples
Sandbox pitfalls
Viewing logs
Setting smart contract state directly
Using snapshots
Performing testing on contracts from a real network
Step-by-step execution
Network/Block configuration
Contributors
License
Donations
Installation
Requires node 16 or higher.

yarn add @ton/sandbox @ton/ton @ton/core @ton/crypto
or

npm i @ton/sandbox @ton/ton @ton/core @ton/crypto
Usage
To use this package, you need to create an instance of the Blockchain class using the static method Blockchain.create as follows:

import { Blockchain } from "@ton/sandbox";

const blockchain = await Blockchain.create()
After that, you can use the low level methods on Blockchain (such as sendMessage) to emulate any messages that you want, but the recommended way to use it is to write wrappers for your contract using the Contract interface from @ton/core. Then you can use blockchain.openContract on instances of such contracts, and they will be wrapped in a Proxy that will supply a ContractProvider as a first argument to all its methods starting with either get or send. Also all send methods will get Promisified and will return results of running the blockchain message queue along with the original method's result in the result field.

A good example of this is the treasury contract that is basically a built-in highload wallet meant to help you write tests for your systems of smart contracts. When blockchain.treasury is called, an instance of TreasuryContract is created and blockchain.openContract is called to "open" it. After that, when you call treasury.send, Blockchain automatically supplies the first provider argument.

For your own contracts, you can draw inspiration from the contracts in the examples - all of them use the provider.internal method to send internal messages using the treasuries passed in from the unit test file. Here is an excerpt of that from NftItem.ts:

import { Address, beginCell, Cell, Contract, ContractProvider, Sender, toNano, Builder } from "@ton/core";

class NftItem implements Contract {
    async sendTransfer(provider: ContractProvider, via: Sender, params: {
        value?: bigint
        to: Address
        responseTo?: Address
        forwardAmount?: bigint
        forwardBody?: Cell | Builder
    }) {
        await provider.internal(via, {
            value: params.value ?? toNano('0.05'),
            body: beginCell()
                .storeUint(0x5fcc3d14, 32) // op
                .storeUint(0, 64) // query id
                .storeAddress(params.to)
                .storeAddress(params.responseTo)
                .storeBit(false) // custom payload
                .storeCoins(params.forwardAmount ?? 0n)
                .storeMaybeRef(params.forwardBody)
                .endCell()
        })
    }
}
When you call nftItem.sendTransfer(treasury.getSender(), { to: recipient }) (with nftItem being an "opened" instance of NftItem), an external message to the wallet represented by treasury will be pushed onto the message queue, then processed, generating an internal message to the NFT contract.

Here is another excerpt that shows the way to interact with get methods from wrappers:

import { Contract, ContractProvider } from "@ton/core";

export type NftItemData = {
    inited: boolean
    index: number
    collection: Address | null
    owner: Address | null
    content: Cell | null
}

class NftItem implements Contract {
    async getData(provider: ContractProvider): Promise<NftItemData> {
        const { stack } = await provider.get('get_nft_data', [])
        return {
            inited: stack.readBoolean(),
            index: stack.readNumber(),
            collection: stack.readAddressOpt(),
            owner: stack.readAddressOpt(),
            content: stack.readCellOpt(),
        }
    }
}
When you call nftItem.getData() (note that just like in the sendTransfer method, you don't need to supply the provider argument - it's done for you on "opened" instances), the provider will query the smart contract contained in blockchain and parse the data according to the code. Note that unlike the send methods, get methods on "opened" instances will return the original result as-is to the caller.

Notes:

All of the methods of contracts that you want to "open" that start with get or send NEED to accept provider: ContractProvider as a first argument (even if not used) due to how the wrapper works.
You can open any contract at any address, even if it is not yet deployed or was deployed by a "parent" opened contract. The only requirement is that the address field (required by the Contract interface) is the address of the contract that you want to open, and that init is present if you want to deploy using methods on the opened instance (in other cases, init is not necessary).
Ideally, at most one call to either provider.internal or provider.external should be made within a send method. Otherwise, you may get hard to interpret (but generally speaking correct) results.
No calls to provider.external or provider.internal should be made within get methods. Otherwise, you will get weird and wrong results in the following send methods of any contract.
Writing tests
Basic test template
You can install additional @ton/test-utils package by running yarn add @ton/test-utils -D or npm i --save-dev @ton/test-utils (with .toHaveTransaction for jest or .transaction or .to.have.transaction for chai matcher) to add additional helpers for ease of testing. Don't forget to import them in your unit test files though!

Writing tests in Sandbox works through defining arbitary actions with the contract and comparing their results with the expected result, for example:

it('should execute with success', async () => {                              // description of the test case
    const res = await main.sendMessage(sender.getSender(), toNano('0.05'));  // performing an action with contract main and saving result in res

    expect(res.transactions).toHaveTransaction({                             // configure the expected result with expect() function
        from: main.address,                                                  // set expected sender for transaction we want to test matcher properties from
        success: true                                                        // set the desirable result using matcher property success
    });

    printTransactionFees(res.transactions);                                  // print table with details on spent fees
});
Test a transaction with matcher
The basic workflow of creating a test is:

Create a specific wrapped Contract entity using blockchain.openContract().
Describe the actions your Contract should perform and save the execution result in res variable.
Verify the properties using the expect() function and the matcher toHaveTransaction().
The toHaveTransaction matcher expects an object with any combination of fields from the FlatTransaction type defined with the following properties

Name	Type	Description
from	Address?	Contract address of the message sender
to	Address	Contract address of the message destination
on	Address	Contract address of the message destination (Alternative name of the property to).
value	bigint?	Amount of Toncoins in the message in nanotons
body	Cell	Message body defined as a Cell
inMessageBounced	boolean?	Boolean flag Bounced. True - message is bounced, False - message is not bounced.
inMessageBounceable	boolean?	Boolean flag Bounceable. True - message can be bounced, False - message can not be bounced.
op	number?	Op code is the operation identifier number (crc32 from TL-B usually). Expected in the first 32 bits of a message body.
initData	Cell?	InitData Cell. Used for contract deployment processes.
initCode	Cell?	initCode Cell. Used for contract deployment processes.
deploy	boolean	Custom Sandbox flag that indicates whether the contract was deployed during this transaction. True if contract before this transaction was not initialized and after this transaction became initialized. Otherwise - False.
lt	bigint	Logical time (set by validators in a normal network, monotonically increases by a set interval in Sandbox). Used for defining order of transactions related to a certain contract
now	bigint	Unix timestamp of the transaction
outMessagesCount	number	Quantity of outbound messages in a certain transaction
oldStatus	AccountStatus	AccountStatus before transaction execution
endStatus	AccountStatus	AccountStatus after transaction execution
totalFees	bigint?	Number of spent fees in nanotons
aborted	boolean?	True - execution of certain transaction aborted and rollbacked because of errors or insufficient gas. Otherwise - False.
destroyed	boolean?	True - if the existing contract was destroyed due to executing a certain transaction. Otherwise - False.
exitCode	number?	TVM exit code (from compute phase)
actionResultCode	number?	Action phase result code
success	boolean?	Custom Sandbox flag that defines the resulting status of a certain transaction. True - if both the compute and the action phase succeeded. Otherwise - False.
You can omit those that you're not interested in, and you can also pass in functions accepting those types returning booleans (true meaning good) to check for example number ranges, message opcodes, etc. Note however that if a field is optional (like from?: Address), then the function needs to accept the optional type, too.

Here is an excerpt of how it's used in the NFT collection example mentioned above:

const buyResult = await buyer.send({
    to: sale.address,
    value: price + toNano('1'),
    sendMode: SendMode.PAY_GAS_SEPARATELY,
})

expect(buyResult.transactions).toHaveTransaction({
    from: sale.address,
    to: marketplace.address,
    value: fee,
})
expect(buyResult.transactions).toHaveTransaction({
    from: sale.address,
    to: collection.address,
    value: fee,
})
(in that example jest is used)

Testing transaction fees
It is possible to configure and update the current time of the Blockchain, which allows one to inspect how much a contract would spend on storage fees.

Suppose we have a main instance defined as a wrapped Contract instance main = blockchain.openContract(/* non-wrapped Main instance */), and we wish to determine the amount of storage fees that will be accrued between two actions within a specified period.

it('should storage fees cost less than 1 TON', async () => {
    const time1 = Math.floor(Date.now() / 1000);                               // current local unix time
    const time2 = time1 + 365 * 24 * 60 * 60;                                  // offset for a year

    blockchain.now = time1;                                                    // set current time
    const res1 = await main.sendMessage(sender.getSender(), toNano('0.05'));   // preview of fees
    printTransactionFees(res1.transactions);

    blockchain.now = time2;                                                    // set current time
    const res2 = await main.sendMessage(sender.getSender(), toNano('0.05'));   // preview of fees
    printTransactionFees(res2.transactions);

    const tx2 = res2.transactions[1];                                          // extract the transaction that executed in a year
    if (tx2.description.type !== 'generic') {
        throw new Error('Generic transaction expected');
    }

    // Check that the storagePhase fees are less than 1 TON over the course of a year
    expect(tx2.description.storagePhase?.storageFeesCollected).toBeLessThanOrEqual(toNano('1'));
});
Cross contract tests
The Sandbox emulates the entire process of executing cross-contract interactions as if they occurred on a real blockchain. The result of sending a message (transfer) contains basic information about all transactions and actions. You can verify all of these by creating specific requirements via expect() for each action and transaction.

res = await main.sendMessage(...);

expect(res).toHaveTransaction(...) // test case
        <...>
expect(res).toHaveTransaction(...) // test case
For instance, with Modern Jetton it's possible to test whether a mint message results in minting to a new jetton wallet contract and returns the excess to the minter contract.

it('minter admin should be able to mint jettons', async () => {
    // can mint from deployer
    let initialTotalSupply = await jettonMinter.getTotalSupply();
    const deployerJettonWallet = await userWallet(deployer.address);
    let initialJettonBalance = toNano('1000.23');
    const mintResult = await jettonMinter.sendMint(deployer.getSender(), deployer.address, initialJettonBalance, toNano('0.05'), toNano('1'));

    expect(mintResult.transactions).toHaveTransaction({ // test transaction of deployment of a jetton wallet
        from: jettonMinter.address,
        to: deployerJettonWallet.address,
        deploy: true,
    });

    expect(mintResult.transactions).toHaveTransaction({ // test transaction of excesses returned to minter
        from: deployerJettonWallet.address,
        to: jettonMinter.address
    });

});
Testing key points
In order to make sure that the contract will work as expected, you need to follow the following points in testing

Test positive flows to make sure your contracts work
Test negative flows to make sure that smart contracts behave correctly under abnormal conditions. Abnormal conditions includes:
incorrect input
action list overflow
insufficient toncoin amount
integer overflow
owner assertions
More information about testing key points can be found here:

Testing key point
Test Examples
You can typically find various tests for Sandbox-based project contracts in the ./tests directory. Learn more from examples:

FunC Test Examples
Tact Test Examples
Sandbox pitfalls
There are several pitfalls in the sandbox due to the limitations of emulation. Be aware of it while testing your smart contracts.

Libs cells not updating in contract by SETLIBCODE, CHANGELIB. They need to be updated manually.
const blockchain = await Blockchain.create();
const code = await compile('Contract');

// consist of a hash of a lib cell and its representation
const libsDict = Dictionary.empty(Dictionary.Keys.Buffer(32), Dictionary.Values.Cell());
libsDict.set(code.hash(), code);

// manualy set libs
blockchain.libs = beginCell().storeDictDirect(libsDict).endCell();
There is no blocks in emulation, so opcodes like PREVBLOCKSINFO, PREVMCBLOCKS, PREVKEYBLOCK will return empty tuple.
The randomness in the TON is always deterministic and the same randomSeed always gives the same random number sequence. If necessary, you can change the randomSeed to make RAND provide result based on provided seed. Currently, there is no way to provide randomSeed in opened contracts.
const res = await blockchain.runGetMethod(example.address,
        'get_method',
        [],
        { randomSeed: randomBytes(32) }
);
const stack = new TupleReader(res.stack);
// read data from stack ...
Because there is no concept of blocks in Sandbox, things like sharding do not work.
Viewing logs
Blockchain and SmartContract use LogsVerbosity to determine what kinds of logs to print. Here is the definition:

type LogsVerbosity = {
    print: boolean
    blockchainLogs: boolean
    vmLogs: Verbosity
    debugLogs: boolean
}

type Verbosity = 'none' | 'vm_logs' | 'vm_logs_full'
Setting verbosity on SmartContracts works like an override with respect to what is set on Blockchain.

debugLogs is enabled by default on the Blockchain instance (so every SmartContract that does not have debugLogs overridden will print debug logs), other kinds of logs are turned off.

print determines whether to console.log all the non-empty logs (if set to false, logs will be collected but will only be exposed in the return values of methods on Blockchain and SmartContract, and not printed to console), defaults to true on the Blockchain instance.

'vm_logs' prints the log of every instruction that was executed, 'vm_logs_full' also includes code cell hashes, locations, and stack information for every instruction executed.

To override verbosity on a specific contract, use await blockchain.setVerbosityForAddress(targetAddress, verbosity), for example:

await blockchain.setVerbosityForAddress(targetAddress, {
    blockchainLogs: true,
    vmLogs: 'vm_logs',
})
After that, the target contract will be using debugLogs from the Blockchain instance to determine whether to print debug logs, but will always print VM logs and blockchain logs.

To set global verbosity, use the blockchain.verbosity setter, for example:

blockchain.verbosity = {
    blockchainLogs: true,
    vmLogs: 'none',
    debugLogs: false,
}
Note that unlike with setVerbosityForAddress, with this setter you have to specify all the values from LogsVerbosity.

Setting smart contract state directly
If you want to test some behavior on a contract if it had specific code, data, and other state fields, but do not want to execute all the required transactions for that, you can directly set the full state of the contract as it is stored in sandbox by using this method on the Blockchain instance:

async setShardAccount(address: Address, account: ShardAccount)
There are 2 helpers exported from sandbox that can help you create the ShardAccount from the common properties: createEmptyShardAccount and createShardAccount.

Note that this is a low-level function and does not check any invariants, such as that the address passed as the argument matches the one that is present in the ShardAccount, meaning it is possible to break stuff if you're not careful when using it.

Using snapshots
It is possible to store the whole Blockchain state in an object and restore this state later. This can be useful to compare the outcomes of different actions after a certain point, or to store the state of the contract system after a long series of configuration actions in order to quickly restore it for all required tests instead of setting it up each time.

To store the state, do the following:

const snapshot = blockchain.snapshot()
To restore the state, do the following:

await blockchain.loadFrom(snapshot)
Note: snapshots store the entire state of a Blockchain instance, that includes:

all contracts' states
the network config
next transaction lt
the unix timestamp (if it is set)
verbosity settings
the libraries dictionary
other internal parameters
Basically, the state of a Blockchain instance after it is restored using a snapshot is the same as if the same actions were performed on that instance as on the instance from which the snapshot originates.

Performing testing on contracts from a real network
It is possible to use Sandbox to perform tests on contracts that are deployed to a real network. To do that, create your Blockchain instance using a RemoteBlockchainStorage, like so:

import { TonClient4 } from '@ton/ton'
import { Blockchain, RemoteBlockchainStorage, wrapTonClient4ForRemote } from '@ton/sandbox'
import { getHttpV4Endpoint } from '@orbs-network/ton-access'
const blockchain = await Blockchain.create({
    storage: new RemoteBlockchainStorage(wrapTonClient4ForRemote(new TonClient4({
        endpoint: await getHttpV4Endpoint({
            network: 'mainnet'
        })
    })))
})
After that, whenever that Blockchain instance tries to read the state of an unknown contract, that contract's state will be pulled from that network. RemoteBlockchainStorage also accepts an optional second argument in its constructor, blockSeqno, and if it is passed, the contracts' states will be pulled from that block number, instead of from the latest known block.

Note: only the states of unknown (do not confuse unknown with uninitialized) contracts will be pulled from the network - that is, if a contract's state has been previously set by any means (creation of a treasury, set manually, or was already pulled before), then it will not be re-read.

Step-by-step execution
In cases where you need to process a few transactions from the transaction chain, but not all of them (for example, a contract generates 1000 transactions but you only need to check the first 10 - in that case, waiting for the whole 1000 transactions to be executed is wasteful), you may do so by using the sendMessageIter method:

const iter = await blockchain.sendMessageIter(testMessage)

for await (const tx of iter) {
    // some kind of processing for tx, for example:
    console.log(tx)
}
This approach allows you to stop the processing of the transaction chain, unlike the usual approaches.

Network/Block configuration
By default, this package will use its stored network configuration to emulate messages. However, you can set any configuration you want when creating the Blockchain instance by passing the configuration cell in the optional params argument in the config field.

Contributors
Special thanks to @dungeon-master-666 for their C++ code of the emulator.

Special thanks to @TrueCarry for their help with performance and other suggestions.