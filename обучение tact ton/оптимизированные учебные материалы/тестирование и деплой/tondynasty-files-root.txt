readme
Ton-Dynasty Contracts
Telegram

Ton Dynasty Contract developed by Perman Lab is a library for efficient smart contract development by tact-lang.

Implementations of standards like TEP-0062, TEP-0074
Reusable traits for common contract types like Lockable, Estimatible, etc.
Provide series of template for ton developers to utilize.
Perman Lab will always stand by you. Ask for our help in Perman Lab Community.
Overview
Installation
Warning

Now we are in the early stage of development. The library is not ready for production use.

Important

Currently, Tact does not support importing from node modules. So you need to copy the source code of the library to your project. We will fix this issue in the future.

git clone https://github.com/Ton-Dynasty/tondynasty-contracts.git
Usage
Once you leverage our library, you can build contracts efficiently.

Example Jetton Contract
import "@stdlib/deploy";
import "./packages/token/jetton/JettonMaster";
import "./packages/token/jetton/JettonWallet";

contract ExampleJettonWallet with JettonWallet {
    balance: Int as coins = 0;
    owner: Address;
    jetton_master: Address;

    init(owner: Address, jetton_master: Address) {
        self.owner = owner;
        self.jetton_master = jetton_master;
    }

    override inline fun calculate_jetton_wallet_init(owner_address: Address): StateInit {
        return initOf ExampleJettonWallet(owner_address, self.jetton_master);
    }
}

contract ExampleJettonMaster with JettonMaster, Deployable {
    total_supply: Int as coins = 0;
    mintable: Bool = true;
    owner: Address;
    jetton_content: Cell;

    init(owner: Address, jetton_content: Cell){
        self.owner = owner;
        self.jetton_content = jetton_content;
    }

    receive("Mint:1") {
        let ctx: Context = context();
        let msg: JettonMint = JettonMint{
            origin: ctx.sender,
            receiver: ctx.sender,
            amount: ton("1"),
            custom_payload: emptyCell(),
            forward_ton_amount: 0,
            forward_payload: emptySlice()
        };
        self._mint_validate(ctx, msg);
        self._mint(ctx, msg);
    }

    override inline fun _mint_validate(ctx: Context, msg: JettonMint) {
        require(self.mintable, "JettonMaster: Jetton is not mintable");
    }

    override inline fun calculate_jetton_wallet_init(owner_address: Address): StateInit {
        return initOf ExampleJettonWallet(owner_address, myAddress());
    }
}
The above code is an example of a jetton contract. You can view Jetton as ERC20 token contract but on TON.

Development Guide
Project structure
contracts - source code of all the smart contracts of the project and their dependencies.
wrappers - wrapper classes (implementing Contract from ton-core) for the contracts, including any [de]serialization primitives and compilation functions.
tests - tests for the contracts.
scripts - scripts used by the project, mainly the deployment scripts.
How to use
Build
yarn build

Test
yarn test

Deploy or run another script
yarn start

genWrapper.sh
#!/bin/bash

# List all directories under 'build' and ask the user to choose one
echo "Available directories under 'build':"
select DIR_NAME in $(find build -maxdepth 1 -mindepth 1 -type d -exec basename {} \;); do
    if [[ -n "$DIR_NAME" ]]; then
        echo "You selected: $DIR_NAME"
        break
    else
        echo "Invalid selection"
    fi
done

# Define the path to the source and destination directories
SRC_DIR="build/$DIR_NAME"
DEST_DIR="wrappers"

# Ensure that the destination directory exists
mkdir -p "$DEST_DIR"

# Loop through each `tact_xxx.ts` file in the source directory
find "$SRC_DIR" -type f -name 'tact_*.ts' | while read -r FILEPATH; do
    # Extract the filename without the path and extension
    FILENAME=$(basename -- "$FILEPATH")
    BASENAME="${FILENAME%.*}"

    # Define the new file path
    NEW_FILE="$DEST_DIR/${DIR_NAME}_${BASENAME#tact_}.ts"

    # Write the export statement to the new file
    echo "export * from '../$SRC_DIR/${BASENAME}';" > "$NEW_FILE"
done

jest.config.ts
import type { Config } from 'jest';

const config: Config = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    testPathIgnorePatterns: ['/node_modules/', '/dist/'],
};

export default config;

package.json
{
    "name": "contracts",
    "version": "0.0.1",
    "scripts": {
        "start": "blueprint run",
        "build": "rm -rf ./build/* && blueprint build --all",
        "dev": "blueprint build",
        "test": "jest",
        "gen": "bash ./genWrapper.sh"
    },
    "license": "MIT",
    "devDependencies": {
        "@ton-community/blueprint": "^0.12.0",
        "@ton-community/sandbox": "^0.11.0",
        "@ton-community/test-utils": "^0.3.0",
        "@types/jest": "^29.5.0",
        "@types/node": "^20.2.5",
        "jest": "^29.5.0",
        "prettier": "^2.8.6",
        "ton": "~13.6.0",
        "ton-core": "^0.51.0",
        "ton-crypto": "^3.2.0",
        "ts-jest": "^29.0.5",
        "ts-node": "^10.9.1",
        "typescript": "^4.9.5"
    },
    "dependencies": {
        "decimal.js": "^10.4.3"
    }
}

/tsconfig.json
{
    "compilerOptions": {
        "target": "ES2020",
        "outDir": "dist",
        "module": "commonjs",
        "declaration": true,
        "esModuleInterop": true,
        "forceConsistentCasingInFileNames": true,
        "strict": true,
        "skipLibCheck": true
    }
}

