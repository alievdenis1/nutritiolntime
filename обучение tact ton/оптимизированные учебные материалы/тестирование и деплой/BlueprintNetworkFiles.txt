NetworkProvider.ts

import { TonClient, TonClient4 } from '@ton/ton';
import { Address, Cell, Contract, ContractProvider, OpenedContract, Sender } from '@ton/core';
import { UIProvider } from '../ui/UIProvider';

export interface NetworkProvider {
    network(): 'mainnet' | 'testnet' | 'custom';
    sender(): Sender;
    api(): TonClient4 | TonClient;
    provider(address: Address, init?: { code?: Cell; data?: Cell }): ContractProvider;
    isContractDeployed(address: Address): Promise<boolean>;
    waitForDeploy(address: Address, attempts?: number, sleepDuration?: number): Promise<void>;
    /**
     * @deprecated
     *
     * Use your Contract's `sendDeploy` method (or similar) together with `waitForDeploy` instead.
     */
    deploy(contract: Contract, value: bigint, body?: Cell, waitAttempts?: number): Promise<void>;
    open<T extends Contract>(contract: T): OpenedContract<T>;
    ui(): UIProvider;
}

createNetworkProvider.ts
import { oneOrZeroOf, sleep, getExplorerLink } from '../utils';
import arg from 'arg';
import { DeeplinkProvider } from './send/DeeplinkProvider';
import { TonConnectProvider } from './send/TonConnectProvider';
import { TonHubProvider } from './send/TonHubProvider';
import {
    Address,
    Cell,
    comment,
    Contract,
    ContractProvider,
    openContract,
    OpenedContract,
    Sender,
    SenderArguments,
    SendMode,
    StateInit,
    toNano,
    Transaction,
    TupleItem,
} from '@ton/core';
import { TonClient, TonClient4 } from '@ton/ton';
import { getHttpV4Endpoint } from '@orbs-network/ton-access';
import { UIProvider } from '../ui/UIProvider';
import { NetworkProvider } from './NetworkProvider';
import { SendProvider } from './send/SendProvider';
import { FSStorage } from './storage/FSStorage';
import path from 'path';
import { TEMP_DIR } from '../paths';
import { mnemonicToPrivateKey } from '@ton/crypto';
import { MnemonicProvider, WalletVersion } from './send/MnemonicProvider';
import { Config } from '../config/Config';
import { CustomNetwork } from '../config/CustomNetwork';

export const argSpec = {
    '--mainnet': Boolean,
    '--testnet': Boolean,
    '--custom': String,
    '--custom-type': String,
    '--custom-version': String,
    '--custom-key': String,

    '--tonconnect': Boolean,
    '--deeplink': Boolean,
    '--tonhub': Boolean,
    '--mnemonic': Boolean,

    '--tonscan': Boolean,
    '--tonviewer': Boolean,
    '--toncx': Boolean,
    '--dton': Boolean,
};

export type Args = arg.Result<typeof argSpec>;

type Network = 'mainnet' | 'testnet' | 'custom';

type Explorer = 'tonscan' | 'tonviewer' | 'toncx' | 'dton';

type ContractProviderFactory = (params: { address: Address; init?: StateInit | null }) => ContractProvider;

class SendProviderSender implements Sender {
    #provider: SendProvider;
    readonly address?: Address;

    constructor(provider: SendProvider) {
        this.#provider = provider;
        this.address = provider.address();
    }

    async send(args: SenderArguments): Promise<void> {
        if (args.bounce !== undefined) {
            console.warn(
                "Warning: blueprint's Sender does not support `bounce` flag, because it is ignored by all used Sender APIs",
            );
            console.warn('To silence this warning, change your `bounce` flags passed to Senders to unset or undefined');
        }

        if (!(args.sendMode === undefined || args.sendMode === SendMode.PAY_GAS_SEPARATELY)) {
            throw new Error('Deployer sender does not support `sendMode` other than `PAY_GAS_SEPARATELY`');
        }

        await this.#provider.sendTransaction(args.to, args.value, args.body ?? undefined, args.init ?? undefined);
    }
}

class WrappedContractProvider implements ContractProvider {
    #address: Address;
    #provider: ContractProvider;
    #init?: StateInit | null;
    #factory: ContractProviderFactory;

    constructor(address: Address, factory: ContractProviderFactory, init?: StateInit | null) {
        this.#address = address;
        this.#provider = factory({ address, init });
        this.#init = init;
        this.#factory = factory;
    }

    async getState() {
        return await this.#provider.getState();
    }

    async get(name: string, args: TupleItem[]) {
        return await this.#provider.get(name, args);
    }

    async external(message: Cell) {
        return await this.#provider.external(message);
    }

    async internal(
        via: Sender,
        args: {
            value: string | bigint;
            bounce: boolean | undefined | null;
            sendMode?: SendMode;
            body: string | Cell | undefined | null;
        },
    ) {
        const init = this.#init && (await this.getState()).state.type !== 'active' ? this.#init : undefined;

        return await via.send({
            to: this.#address,
            value: typeof args.value === 'string' ? toNano(args.value) : args.value,
            sendMode: args.sendMode,
            bounce: args.bounce,
            init,
            body: typeof args.body === 'string' ? comment(args.body) : args.body,
        });
    }

    open<T extends Contract>(contract: T): OpenedContract<T> {
        return openContract(
            contract,
            (params) => new WrappedContractProvider(params.address, this.#factory, params.init),
        );
    }

    getTransactions(address: Address, lt: bigint, hash: Buffer, limit?: number): Promise<Transaction[]> {
        return this.#provider.getTransactions(address, lt, hash, limit);
    }
}

class NetworkProviderImpl implements NetworkProvider {
    #tc: TonClient4 | TonClient;
    #sender: Sender;
    #network: Network;
    #explorer: Explorer;
    #ui: UIProvider;

    constructor(tc: TonClient4 | TonClient, sender: Sender, network: Network, explorer: Explorer, ui: UIProvider) {
        this.#tc = tc;
        this.#sender = sender;
        this.#network = network;
        this.#explorer = explorer;
        this.#ui = ui;
    }

    network(): 'mainnet' | 'testnet' | 'custom' {
        return this.#network;
    }

    explorer(): 'tonscan' | 'tonviewer' | 'toncx' | 'dton' {
        return this.#explorer;
    }

    sender(): Sender {
        return this.#sender;
    }

    api(): TonClient4 | TonClient {
        return this.#tc;
    }

    provider(address: Address, init?: StateInit | null): ContractProvider {
        const factory = (params: { address: Address; init?: StateInit | null }) =>
            this.#tc.provider(params.address, params.init);
        return new WrappedContractProvider(address, factory, init);
    }

    async isContractDeployed(address: Address): Promise<boolean> {
        if (this.#tc instanceof TonClient4) {
            return this.#tc.isContractDeployed((await this.#tc.getLastBlock()).last.seqno, address);
        } else {
            return (await this.#tc.getContractState(address)).state === 'active';
        }
    }

    async waitForDeploy(address: Address, attempts: number = 10, sleepDuration: number = 2000) {
        if (attempts <= 0) {
            throw new Error('Attempt number must be positive');
        }

        for (let i = 1; i <= attempts; i++) {
            this.#ui.setActionPrompt(`Awaiting contract deployment... [Attempt ${i}/${attempts}]`);
            const isDeployed = await this.isContractDeployed(address);
            if (isDeployed) {
                this.#ui.clearActionPrompt();
                this.#ui.write(`Contract deployed at address ${address.toString()}`);
                this.#ui.write(
                    `You can view it at ${getExplorerLink(address.toString(), this.#network, this.#explorer)}`,
                );
                return;
            }
            await sleep(sleepDuration);
        }

        this.#ui.clearActionPrompt();
        throw new Error("Contract was not deployed. Check your wallet's transactions");
    }

    /**
     * @deprecated
     *
     * Use your Contract's `sendDeploy` method (or similar) together with `waitForDeploy` instead.
     */
    async deploy(contract: Contract, value: bigint, body?: Cell, waitAttempts: number = 10) {
        const isDeployed = await this.isContractDeployed(contract.address);
        if (isDeployed) {
            throw new Error('Contract is already deployed!');
        }

        if (!contract.init) {
            throw new Error('Contract has no init!');
        }

        await this.#sender.send({
            to: contract.address,
            value,
            body,
            init: contract.init,
        });

        if (waitAttempts <= 0) return;

        await this.waitForDeploy(contract.address, waitAttempts);
    }

    open<T extends Contract>(contract: T): OpenedContract<T> {
        return openContract(contract, (params) => this.provider(params.address, params.init ?? null));
    }

    ui(): UIProvider {
        return this.#ui;
    }
}

async function createMnemonicProvider(client: TonClient4 | TonClient, ui: UIProvider) {
    const mnemonic = process.env.WALLET_MNEMONIC ?? '';
    const walletVersion = process.env.WALLET_VERSION ?? '';
    if (mnemonic.length === 0 || walletVersion.length === 0) {
        throw new Error(
            'Mnemonic deployer was chosen, but env variables WALLET_MNEMONIC and WALLET_VERSION are not set',
        );
    }
    const keyPair = await mnemonicToPrivateKey(mnemonic.split(' '));
    return new MnemonicProvider({
        version: walletVersion.toLowerCase() as WalletVersion,
        client,
        secretKey: keyPair.secretKey,
        ui,
    });
}

class NetworkProviderBuilder {
    constructor(
        private args: Args,
        private ui: UIProvider,
        private config?: Config,
        private allowCustom = true,
    ) {}

    async chooseNetwork(): Promise<Network> {
        let network = oneOrZeroOf({
            mainnet: this.args['--mainnet'],
            testnet: this.args['--testnet'],
            custom: this.args['--custom'] !== undefined,
        });

        if (network !== undefined) {
            return network;
        }

        if (this.config?.network !== undefined) {
            return typeof this.config.network === 'string' ? this.config.network : 'custom';
        }

        network = await this.ui.choose('Which network do you want to use?', ['mainnet', 'testnet', 'custom'], (c) => c);
        if (network === 'custom') {
            const defaultCustomEndpoint = 'http://localhost:8081/';
            this.args['--custom'] = (
                await this.ui.input(`Provide a custom API v2 endpoint (default is ${defaultCustomEndpoint})`)
            ).trim();
            if (this.args['--custom'] === '') this.args['--custom'] = defaultCustomEndpoint;
        }

        return network;
    }

    chooseExplorer(): Explorer {
        return (
            oneOrZeroOf({
                tonscan: this.args['--tonscan'],
                tonviewer: this.args['--tonviewer'],
                toncx: this.args['--toncx'],
                dton: this.args['--dton'],
            }) ?? 'tonscan'
        );
    }

    async chooseSendProvider(network: Network, client: TonClient4 | TonClient): Promise<SendProvider> {
        let deployUsing = oneOrZeroOf({
            tonconnect: this.args['--tonconnect'],
            deeplink: this.args['--deeplink'],
            tonhub: this.args['--tonhub'],
            mnemonic: this.args['--mnemonic'],
        });

        if (!deployUsing) {
            deployUsing = (
                await this.ui.choose(
                    'Which wallet are you using?',
                    [
                        {
                            name: 'TON Connect compatible mobile wallet (example: Tonkeeper)',
                            value: 'tonconnect',
                        },
                        {
                            name: 'Create a ton:// deep link',
                            value: 'deeplink',
                        },
                        {
                            name: 'Tonhub wallet',
                            value: 'tonhub',
                        },
                        {
                            name: 'Mnemonic',
                            value: 'mnemonic',
                        },
                    ],
                    (c) => c.name,
                )
            ).value as any;
        }

        const storagePath = path.join(TEMP_DIR, network, deployUsing! + '.json');

        let provider: SendProvider;
        switch (deployUsing) {
            case 'deeplink':
                provider = new DeeplinkProvider(this.ui);
                break;
            case 'tonconnect':
                if (network === 'custom') throw new Error('Tonkeeper cannot work with custom network.');
                provider = new TonConnectProvider(new FSStorage(storagePath), this.ui);
                break;
            case 'tonhub':
                if (network === 'custom') throw new Error('TonHub cannot work with custom network.');
                provider = new TonHubProvider(network, new FSStorage(storagePath), this.ui);
                break;
            case 'mnemonic':
                provider = await createMnemonicProvider(client, this.ui);
                break;
            default:
                throw new Error('Unknown deploy option');
        }

        return provider;
    }

    async build(): Promise<NetworkProvider> {
        let network = await this.chooseNetwork();
        const explorer = this.chooseExplorer();

        if (
            network !== 'custom' &&
            (this.args['--custom-key'] !== undefined ||
                this.args['--custom-type'] !== undefined ||
                this.args['--custom-version'] !== undefined)
        ) {
            throw new Error('Cannot use custom parameters with a non-custom network');
        }

        let tc;
        if (network === 'custom') {
            let configNetwork: CustomNetwork | undefined = undefined;
            if (this.config?.network !== undefined && typeof this.config.network !== 'string') {
                configNetwork = this.config.network;
            }
            if (this.args['--custom'] !== undefined) {
                const inputVer = this.args['--custom-version'];
                let version: 'v4' | 'v2' | undefined = undefined;
                if (inputVer !== undefined) {
                    version = inputVer.toLowerCase() as any; // checks come later
                }
                const inputType = this.args['--custom-type'];
                let type: 'mainnet' | 'testnet' | 'custom' | undefined = undefined;
                if (inputType !== undefined) {
                    type = inputType as any; // checks come later
                }
                configNetwork = {
                    endpoint: this.args['--custom'],
                    version,
                    key: this.args['--custom-key'],
                    type,
                };
            }
            if (configNetwork === undefined) {
                throw new Error('Custom network is (somehow) undefined');
            }
            if (configNetwork.version === undefined || configNetwork.version === 'v2') {
                tc = new TonClient({
                    endpoint: configNetwork.endpoint,
                    apiKey: configNetwork.key,
                });
            } else if (configNetwork.version === 'v4') {
                if (configNetwork.key !== undefined) {
                    throw new Error('Cannot use a custom API key with a v4 API');
                }
                tc = new TonClient4({
                    endpoint: configNetwork.endpoint,
                });
            } else {
                throw new Error('Unknown API version: ' + configNetwork.version);
            }

            if (configNetwork.type !== undefined) {
                const ct = configNetwork.type.toLowerCase();
                if (!['mainnet', 'testnet', 'custom'].includes(ct)) {
                    throw new Error('Unknown network type: ' + ct);
                }
                network = ct as Network;
            } else if (!this.allowCustom) {
                throw new Error('The usage of this network provider requires either mainnet or testnet');
            }
        } else {
            tc = new TonClient4({
                endpoint: await getHttpV4Endpoint({ network }),
            });
        }

        const sendProvider = await this.chooseSendProvider(network, tc);

        try {
            await sendProvider.connect();
        } catch (e) {
            console.error('Unable to connect to wallet.');
            process.exit(1);
        } finally {
            this.ui.setActionPrompt('');
        }

        const sender = new SendProviderSender(sendProvider);

        return new NetworkProviderImpl(tc, sender, network, explorer, this.ui);
    }
}

export async function createNetworkProvider(
    ui: UIProvider,
    args: Args,
    config?: Config,
    allowCustom = true,
): Promise<NetworkProvider> {
    return await new NetworkProviderBuilder(args, ui, config, allowCustom).build();
}

send/DeeplinkProvider.ts
import { Address, beginCell, Cell, StateInit, storeStateInit } from '@ton/core';
import { SendProvider } from './SendProvider';
import { tonDeepLink } from '../../utils';
import qrcode from 'qrcode-terminal';
import { UIProvider } from '../../ui/UIProvider';

export class DeeplinkProvider implements SendProvider {
    #ui: UIProvider;

    constructor(ui: UIProvider) {
        this.#ui = ui;
    }

    async connect(): Promise<void> {
        return;
    }

    async sendTransaction(address: Address, amount: bigint, payload?: Cell, stateInit?: StateInit) {
        const deepLink = tonDeepLink(
            address,
            amount,
            payload,
            stateInit ? beginCell().storeWritable(storeStateInit(stateInit)).endCell() : undefined,
        );

        try {
            this.#ui.write('\n');
            qrcode.generate(deepLink, { small: true }, (qr) => this.#ui.write(qr));
            this.#ui.write('\n');
            this.#ui.write(deepLink);
            this.#ui.write('\nScan the QR code above, or open the ton:// link to send this transaction');

            await this.#ui.prompt('Press enter when transaction was issued');
        } catch (err: unknown) {
            this.#ui.write(deepLink);
            this.#ui.write('\n');

            if (err instanceof Error && err.message.includes('code length overflow')) {
                this.#ui.write('Message is too large to be sent via QR code. Please use the ton:// link or another method.');
                process.exit(1);
            }
            throw err;
        }
    }

    address(): Address | undefined {
        return undefined;
    }
}

send/TonConnectProvider.ts
import qrcode from 'qrcode-terminal';
import TonConnect, { IStorage, WalletInfo, WalletInfoRemote } from '@tonconnect/sdk';
import { Address, beginCell, Cell, StateInit, storeStateInit } from '@ton/core';
import { SendProvider } from './SendProvider';
import { Storage } from '../storage/Storage';
import { UIProvider } from '../../ui/UIProvider';

class TonConnectStorage implements IStorage {
    #inner: Storage;

    constructor(inner: Storage) {
        this.#inner = inner;
    }

    async setItem(key: string, value: string): Promise<void> {
        return await this.#inner.setItem(key, value);
    }
    async getItem(key: string): Promise<string | null> {
        return await this.#inner.getItem(key);
    }
    async removeItem(key: string): Promise<void> {
        return await this.#inner.removeItem(key);
    }
}

function isRemote(walletInfo: WalletInfo): walletInfo is WalletInfoRemote {
    return 'universalLink' in walletInfo && 'bridgeUrl' in walletInfo;
}

export class TonConnectProvider implements SendProvider {
    #connector: TonConnect;
    #ui: UIProvider;

    constructor(storage: Storage, ui: UIProvider) {
        this.#connector = new TonConnect({
            storage: new TonConnectStorage(storage),
            manifestUrl:
                'https://raw.githubusercontent.com/ton-org/blueprint/main/tonconnect/manifest.json',
        });
        this.#ui = ui;
    }

    async connect(): Promise<void> {
        await this.connectWallet();
        this.#ui.write(
            `Connected to wallet at address: ${Address.parse(this.#connector.wallet!.account.address).toString()}\n`,
        );
    }

    address(): Address | undefined {
        if (!this.#connector.wallet) return undefined;

        return Address.parse(this.#connector.wallet.account.address);
    }

    private async connectWallet(): Promise<void> {
        const wallets = (await this.#connector.getWallets()).filter(isRemote);

        await this.#connector.restoreConnection();

        if (this.#connector.wallet) {
            return;
        }

        const wallet = await this.#ui.choose('Choose your wallet', wallets, (w) => w.name);

        this.#ui.setActionPrompt('Connecting to wallet...');

        const url = this.#connector.connect({
            universalLink: wallet.universalLink,
            bridgeUrl: wallet.bridgeUrl,
        }) as string;

        this.#ui.write('\n');

        qrcode.generate(url, { small: true }, (qr) => this.#ui.write(qr));

        this.#ui.write('\n' + url + '\n\n');

        this.#ui.setActionPrompt('Scan the QR code in your wallet or open the link...');

        return new Promise((resolve, reject) => {
            this.#connector.onStatusChange((w) => {
                if (w) {
                    resolve();
                } else {
                    reject('Wallet is not connected');
                }
            }, reject);
        });
    }

    async sendTransaction(address: Address, amount: bigint, payload?: Cell, stateInit?: StateInit) {
        this.#ui.setActionPrompt('Sending transaction. Approve in your wallet...');

        const result = await this.#connector.sendTransaction({
            validUntil: Date.now() + 5 * 60 * 1000,
            messages: [
                {
                    address: address.toString(),
                    amount: amount.toString(),
                    payload: payload?.toBoc().toString('base64'),
                    stateInit: stateInit
                        ? beginCell().storeWritable(storeStateInit(stateInit)).endCell().toBoc().toString('base64')
                        : undefined,
                },
            ],
        });

        this.#ui.clearActionPrompt();
        this.#ui.write('Sent transaction');

        return result;
    }
}

send/TonHubProvider.ts
import { Address, beginCell, Cell, StateInit, storeStateInit } from '@ton/core';
import { SendProvider } from './SendProvider';
import { TonhubConnector, TonhubSessionStateReady, TonhubTransactionRequest } from 'ton-x';
import qrcode from 'qrcode-terminal';
import { Storage } from '../storage/Storage';
import { UIProvider } from '../../ui/UIProvider';

const KEY_NAME = 'tonhub_session';

type SavedSession = TonhubSessionStateReady & { id: string; seed: string };

export class TonHubProvider implements SendProvider {
    #connector: TonhubConnector;
    #storage: Storage;
    #ui: UIProvider;
    #session?: SavedSession;

    constructor(network: 'mainnet' | 'testnet', storage: Storage, ui: UIProvider) {
        this.#connector = new TonhubConnector({
            network,
        });
        this.#storage = storage;
        this.#ui = ui;
    }

    private async getExistingSession() {
        const sessionString = await this.#storage.getItem(KEY_NAME);

        if (sessionString === null) return undefined;

        let session: SavedSession = JSON.parse(sessionString);

        const state = await this.#connector.getSessionState(session.id);

        if (state.state === 'ready') {
            session = {
                ...state,
                id: session.id,
                seed: session.seed,
            };

            await this.#storage.setItem(KEY_NAME, JSON.stringify(session));

            return session;
        }
    }

    private async getSession() {
        const existing = await this.getExistingSession();
        if (existing !== undefined) return existing;

        const createdSession = await this.#connector.createNewSession({
            name: 'TON template project',
            url: 'https://example.com/',
        });

        this.#ui.setActionPrompt('Connecting to wallet...\n');

        this.#ui.write('\n');

        qrcode.generate(createdSession.link, { small: true }, (qr) => this.#ui.write(qr));

        this.#ui.write('\n' + createdSession.link + '\n\n');

        this.#ui.setActionPrompt('Scan the QR code in your wallet or open the link...');

        const state = await this.#connector.awaitSessionReady(createdSession.id, 5 * 60 * 1000);

        if (state.state === 'ready') {
            const session: SavedSession = {
                ...state,
                id: createdSession.id,
                seed: createdSession.seed,
            };

            await this.#storage.setItem(KEY_NAME, JSON.stringify(session));

            return session;
        }

        throw new Error('Could not create new session');
    }

    async connect() {
        this.#session = await this.getSession();
        this.#ui.write(`Connected to wallet at address: ${Address.parse(this.#session.wallet.address).toString()}\n`);
    }

    address(): Address | undefined {
        if (!this.#session) return undefined;

        return Address.parse(this.#session.wallet.address);
    }

    async sendTransaction(address: Address, amount: bigint, payload?: Cell, stateInit?: StateInit) {
        if (!this.#session) throw new Error('TonhubProvider is not connected');

        const request: TonhubTransactionRequest = {
            seed: this.#session.seed,
            appPublicKey: this.#session.wallet.appPublicKey,
            to: address.toString(),
            value: amount.toString(),
            timeout: 5 * 60 * 1000,
            payload: payload ? payload.toBoc().toString('base64') : undefined,
            stateInit: stateInit
                ? beginCell().storeWritable(storeStateInit(stateInit)).endCell().toBoc().toString('base64')
                : undefined,
        };

        this.#ui.setActionPrompt('Sending transaction. Approve it in your wallet...');

        const response = await this.#connector.requestTransaction(request);

        if (response.type !== 'success') {
            throw new Error(`Tonhub transaction request was not successful (${response.type})`);
        }

        this.#ui.clearActionPrompt();
        this.#ui.write('Sent transaction');

        return response;
    }
}

send/MnemonicProvider.ts
import {
    TonClient,
    TonClient4,
    WalletContractV1R1,
    WalletContractV1R2,
    WalletContractV1R3,
    WalletContractV2R1,
    WalletContractV2R2,
    WalletContractV3R1,
    WalletContractV3R2,
    WalletContractV4,
} from '@ton/ton';
import {
    Address,
    Cell,
    Contract,
    ContractProvider,
    MessageRelaxed,
    openContract,
    OpenedContract,
    SendMode,
    StateInit,
} from '@ton/core';
import { SendProvider } from './SendProvider';
import { keyPairFromSecretKey } from '@ton/crypto';
import { UIProvider } from '../../ui/UIProvider';

interface WalletInstance extends Contract {
    getSeqno(provider: ContractProvider): Promise<number>;

    sendTransfer(
        provider: ContractProvider,
        args: {
            seqno: number;
            secretKey: Buffer;
            messages: MessageRelaxed[];
            sendMode?: SendMode;
            timeout?: number;
        },
    ): Promise<void>;
}

interface WalletClass {
    create(args: { workchain: number; publicKey: Buffer }): WalletInstance;
}

export type WalletVersion = 'v1r1' | 'v1r2' | 'v1r3' | 'v2r1' | 'v2r2' | 'v3r1' | 'v3r2' | 'v4';

const wallets: Record<WalletVersion, WalletClass> = {
    v1r1: WalletContractV1R1,
    v1r2: WalletContractV1R2,
    v1r3: WalletContractV1R3,
    v2r1: WalletContractV2R1,
    v2r2: WalletContractV2R2,
    v3r1: WalletContractV3R1,
    v3r2: WalletContractV3R2,
    v4: WalletContractV4,
};

export class MnemonicProvider implements SendProvider {
    #wallet: OpenedContract<WalletInstance>;
    #secretKey: Buffer;
    #client: TonClient4 | TonClient;
    #ui: UIProvider;

    constructor(params: {
        version: WalletVersion;
        workchain?: number;
        secretKey: Buffer;
        client: TonClient4 | TonClient;
        ui: UIProvider;
    }) {
        if (!(params.version in wallets)) {
            throw new Error(`Unknown wallet version ${params.version}`);
        }

        const kp = keyPairFromSecretKey(params.secretKey);
        this.#client = params.client;
        this.#wallet = openContract<WalletInstance>(
            wallets[params.version].create({
                workchain: params.workchain ?? 0,
                publicKey: kp.publicKey,
            }),
            (params) => this.#client.provider(params.address, params.init),
        );
        this.#secretKey = kp.secretKey;
        this.#ui = params.ui;
    }

    async connect() {
        this.#ui.write(`Connected to wallet at address: ${this.address()}\n`);
    }

    async sendTransaction(
        address: Address,
        amount: bigint,
        payload?: Cell | undefined,
        stateInit?: StateInit | undefined,
    ) {
        await this.#wallet.sendTransfer({
            seqno: await this.#wallet.getSeqno(),
            secretKey: this.#secretKey,
            messages: [
                {
                    init: stateInit,
                    body: payload ?? new Cell(),
                    info: {
                        type: 'internal',
                        ihrDisabled: true,
                        ihrFee: 0n,
                        bounce: true,
                        bounced: false,
                        dest: address,
                        value: { coins: amount },
                        forwardFee: 0n,
                        createdAt: 0,
                        createdLt: 0n,
                    },
                },
            ],
        });

        this.#ui.write('Sent transaction');
    }

    address() {
        return this.#wallet.address;
    }
}

send/SendProvider.ts
import { Address, Cell, StateInit } from '@ton/core';

export interface SendProvider {
    connect(): Promise<void>;
    sendTransaction(address: Address, amount: bigint, payload?: Cell, stateInit?: StateInit): Promise<any>;
    address(): Address | undefined;
}

storage/FSStorage.ts
import path from 'path';
import fs from 'fs/promises';
import { Storage } from './Storage';

type StorageObject = {
    [k: string]: string;
};

export class FSStorage implements Storage {
    #path: string;

    constructor(path: string) {
        this.#path = path;
    }

    async #readObject(): Promise<StorageObject> {
        try {
            return JSON.parse((await fs.readFile(this.#path)).toString('utf-8'));
        } catch (e) {
            return {};
        }
    }

    async #writeObject(obj: StorageObject): Promise<void> {
        await fs.mkdir(path.dirname(this.#path), { recursive: true });
        await fs.writeFile(this.#path, JSON.stringify(obj));
    }

    async setItem(key: string, value: string): Promise<void> {
        const obj = await this.#readObject();
        obj[key] = value;
        await this.#writeObject(obj);
    }

    async getItem(key: string): Promise<string | null> {
        const obj = await this.#readObject();
        return obj[key] ?? null;
    }

    async removeItem(key: string): Promise<void> {
        const obj = await this.#readObject();
        delete obj[key];
        await this.#writeObject(obj);
    }
}

storage/Storage.ts
export interface Storage {
    /**
     * Saves the `value` to the storage. Value can be accessed later by the `key`. Implementation may use backend as a storage due to the fact that the function returns a promise.
     * @param key key to access to the value later.
     * @param value value to save.
     */
    setItem(key: string, value: string): Promise<void>;
    /**
     * Reads the `value` from the storage. Implementation may use backend as a storage due to the fact that the function returns a promise.
     * @param key key to access the value.
     */
    getItem(key: string): Promise<string | null>;
    /**
     * Removes the `value` from the storage. Implementation may use backend as a storage due to the fact that the function returns a promise.
     * @param key key to access the value.
     */
    removeItem(key: string): Promise<void>;
}
